# 평범한 베낭 

https://www.acmicpc.net/problem/12865

## 문제 설명 
물건이 N개 있고 각 물건에는 무게 W와 가치 V가 존재한다. 
베낭 안에는 K만큼의 무게만 넣을 수 있다 할 때 
최대한 물건의 가치를 높게 가져 갈 수 있도록 하자

첫 번째 줄에는 물건 수(N) , 베낭이 버틸 수 있는 무게(K) 
두 번째 줄부터 (N) 번째 줄은  물건의 무게(W) , 가치(V) 를 입력한다.  


## 풀이 코드
```python
n, k = map(int, input().split()) # 입력 (물건 수 n , 무게 k)

thing = [[0,0]]
d = [[0]*(k+1) for _ in range(n+1)] 

for i in range(n): # 물건 수 만큼 반복해서 배열 늘림 . 
    thing.append(list(map(int, input().split()))) 

for i in range(1, n+1): 
    for j in range(1, k+1):
        w = thing[i][0] # 각 물건의 무게 
        v = thing[i][1] # 각 물건의 가치

        if j < w: # 각 물건의 무게가 더 클 경우  
            d[i][j] = d[i-1][j]
        else: # 전체 무게가 더 클 경우 
            d[i][j] = max(d[i-1][j], d[i-1][j-w]+v)

print(d[n][k]) # 최종 결과 
```

처음에 받을 n과 k를 우선적으로 input 작성  

무게와 가치를 한 곳에 리스트로 저장한다  

배열의 길이는 n만큼 가져가야 하기 때문에 반복문을 통해 늘려놓는다. 

우선순위는 무게이다  가치가 아무리 높아도 무게가 넘어가면 안된다 
무게를 기준으로 먼저 잡는다 .. 

요구한 무게까지 도달할 때 까지 계속 집어 넣는다 d\[i\]\[j\] = d\[i-1\]\[j\] 부분 

요구한 무게를 초과하게 되면 이후부터 가치를 따지면서 물건을 고르기 시작한다 (뒤에 v를 넣은 이유)
```python
d[i][j] = max(d[i-1][j], d[i-1][j-w]+v)
```

