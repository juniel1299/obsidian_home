재귀 함수와 매우 유사한 방식의 알고리즘이다.  
다른점은 큰 문제를 작은 문제들로 분할하여 푼다는 점이 있다. 

DP가 적용되기 위해서 필요한 조건 
1. Overlapping Subproblems (겹치는 부분 문제)
2. Optimal Substructure (최적 부분 구조)

DP는 문제를 나누고 해당 문제의 결과 값을 재활용하여 전체의 답을 구하는 형태이므로 동일한 작은 문제들이 반복되어 나타날 때 유리하다.  


부분 문제의 최적 결과값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우에 유리하다.  


중복을 줄일 수 있다는 장점으로 인해 시간 복잡도가 줄어드는 반면, DP는 중간 과정을 저장한다는 특징 때문에 메모리 사용량이 크다는 단점이 존재한다.  
## 진행 방식
1. 변수 값에 따른 결과를 저장하는 배열과 같은 요소를 만들고 결과를 저장한다 -> 저장한 값들을 활용 ㅋㅋ
2. 변수 사이에 관계식 만들기
(피보나치) f(n) = f(n-1) + f(n-2)


- Top-Down 방식 (재귀) Memoization 방식 \[피보나치\]
> 큰 문제를 작은 부분 문제로 나누어 해결하는 방식입니다. 
> 이를 위해 재귀 함수를 사용하여 문제를 작은 부분 문제들로 쪼개고, 중복 계산을 피하기 위해 이전에 계산한 값을 저장하는 Memoization을 활용합니다.
>  Memoization은 캐싱을 통해 이전 계산 결과를 저장하여 중복 계산을 피하는 것을 의미합니다.

- Bottom-Up 방식 (반복문) Tabulation 방식 \[베낭\]
> Bottom-Up 방식은 작은 부분 문제부터 차례대로 해결하여 전체 문제를 해결하는 방식입니다. 
> 이를 위해 반복문을 사용하여 반복적으로 부분 문제들을 해결하고,결과를 배열 등에 저장합니다.
### 예시 문제

[[예시 문제]]

계단 오르기 (실버3)
https://www.acmicpc.net/problem/2579

카드 구매하기 (실버1)
https://www.acmicpc.net/problem/11052

알약(골드5)
https://www.acmicpc.net/problem/4811

안녕(실버2)
https://www.acmicpc.net/problem/1535