# 빅오 표기법
알고리즘의 복잡도를 판단하는 척도  
- 시간 복잡도
- 공간 복잡도

2가지로 구성 되어있으며,   
시간복잡도의 경우 연산의 횟수를 의미하며,   
공간복잡도의 경우 프로그램을 실행에서 완료단계까지의 자원 공간의 양을 의미한다.  

## 시간 복잡도 표기법 
- Big-O 표기법 (빅오 표기법) : 알고리즘 최악의 실행 시간을 표기함 (가장 적합하지 않은 알고리즘 찾기 )  -> 그래도 최소한 동작은 한다는 보장되는 성능은 갖추기 때문에 제일 많이 사용함  

- Big-Ω 표기법 (빅 오메가 표기법) : 알고리즘의 최상의 실행 시간을 표기한다.  

- Big-θ 표기법 (빅 세타 표기법) : 알고리즘의 평균 실행 시간을 표기한다.  


### 빅오 표기법 특징
**시간 복잡도에서 영향이 거의 끼치지 않는 내용은 다 배제하고 표기한다.**

1. 상수항 무시 
	- 알고리즘이 O(N+5)의 복잡도를 가질 때 상수를 생략 -> O(N) 표기함 .

2. 계수도 무시 
	- 알고리즘이 O(3N) 복잡도를 가질 때 계수를 생략 -> O(N) 표기함 

3. 최고차항만 표기한다.
	- 알고리즘이 O(3N^3+2N^2+N+5) 가질 때 최고 차항인 O(N^3)만 표기하고 나머지는 생략

### 빅오 표기법 종류


![[빅오표기법.png]]


1. O(1) 
	-  입력값(N)이 증가해도 실행시간은 동일한 알고리즘, index로 접근하여 바로 처리가 가능한 연산 과정의 시간 복잡도 ->기본 연산 수


2. O(log N) 
	- 연산이 한번 실행 될 때마다 데이터의 크기가 절반으로 감소하는 알고리즘 
		- 대표적으로 Binary Search 알고리즘 , tree 형태의 자료구조 탐색에서 많이 보임

3. O(N)
	- 입력값(N)이 증가함에 따라 실행시간도 선형적으로 증가하는 알고리즘
		- 대표적으로 for문 (1번만 쓰는)

4. O(N log N)
	- O 알고리즘과 O(log N) 알고리즘이 섞인 경우에 나타나는 형태
		- 대표적으로 퀵 , 병합 , 힙 정렬 존재


5. O(N^2)
	- O 알고리즘과 O(N log N) 알고리즘이 섞인 경우에 나타나는 형태 
		- 2중 for문 , 삽입 정렬, 선택 정렬, 버블정렬

6. O(2^N)